#include<iostream>
#include<thread>
#include<queue>
#include<condition_variable>
#include<mutex>
#include <chrono>
#include<ctime>
using namespace std;

#define DEBUG 1

// Callback contains the string and the time_point is the time when it needs to be executed
// time_point is wrt to the time when it is created

class callback {
public:
	string str;
	chrono::time_point<chrono::system_clock> p;

	callback(string str, chrono::seconds s1) {
		this->str = str;
		this->p = chrono::system_clock::now() + s1;
	}

	string getName() {
		return str;
	}

	chrono::time_point<chrono::system_clock> getTime() {
		return p;
	}

	

};


bool operator < (const callback& a ,const callback& b) {
	if (a.p == b.p) {
		return a.str.length() > b.str.length();
	}
	return a.p > b.p;
}



// This is the callback manager 
// This contains the priority queue which keeps all the callbacks based on their time of execution
// >>>> when a callback is pushed into the queue , we need to notify the executor of callback
// >>>> The executor waits till it gets the notification:
//	    > it checks if it an empty queue, or else it goes into waiting state again
//      > it then goes to a while loop , that while loop is there till queue is empty
//        in that it checks the time difference between the time of the top callback(min exection time_point because it is min heap) and the current time.
//		  Then based on that time differnce/duration , it check if it has to be executed now or not.
//					>>> if the duration is <=0 then brake from the inner while loop and implement the callback
//		            >>> or else the executor waits for the duration just calculated above till another notification of another callback being added to the queue comes.  
class CallbackMechanism {
private:
	priority_queue<callback> q;
	mutex mu;
	condition_variable condVar;

public:

	CallbackMechanism() {}

	void registerCallback(callback& c) {
		unique_lock<mutex> locker(mu);
		q.push(c);
		condVar.notify_one();
	}

	void execute() {
		
		// this loop is there for making this executor to run for an indefinate time
		// *** we can change it to a certain number of callbacks in the queue but that is something of an easy modification. 
		while (true) {
			unique_lock<mutex> locker(mu);
			// Here I am using a predicate the size of the queue or else it would have been kept inside a while loop that checks the size of the queue
			// to check for any spurious wakeups
			
			// Even if all the threads that register their callbacks run (and hence also all the notifications (generated by register threads) are missed by the executor thread( it hasnt started yet)) 
			// before the thread that has to execute them, there wont be any problem because the first thing that gets checked as a predicate over here is the size of the queue.
			condVar.wait(locker, [=] {
				return q.size() > 0 ? true : false;
				});

			// This while loop is necessary because if we remove it , the duration will be calculated once for the top callback , and on an arrival of a notification 
			// the condVar will get back up and proceed with the execution . This will not be correct because we need a re-evaluation of wait time of the condVar: 
			// >>> 1st case: the surious wake up is to be avoided and we are not using any predicate to check that in the condVar , hence the while loop 
			// >>> 2nd case: the added callback may have nearer time of execution w.r.t the previous callback time of execution
			//               hence the condVar needs to wait for the updated time that will be calculated inside a loop , so we need a while loop
			// >>> 3rd case: the added callback has the time of execution that is further than the top callback in the queue, but that just does not mean the the thread should
			//               procedd with the execution. Similar to 2nd case.
			// ***the condVar was supposed to wait more because the time to implement the callback wasnt reached , hence it needs to check again i.e. the while loop is needed to go thrugh the process
			// whenever the condVar is done waiting it needs to come out of the while loop and that is done by calculating the duration as <=0 , the while loop breaks and the execution part is reached 
			while (q.size() != 0) {
				callback tt = q.top();

				chrono::duration<double, std::milli> p = tt.getTime() - chrono::system_clock::now();

				if (p <= 0ms) {
					break;
				}

				condVar.wait_for(locker, p);
			}
			
			// Execution part of a callback --- here we are just printing the values from the callback
			// We can replace only the printing of the values to some function call as per the implementation inside the callback
			callback tt = q.top();
			q.pop();
			cout << tt.getName() << " got executed at " << std::chrono::system_clock::to_time_t(tt.getTime())<<endl;

			locker.unlock();
		}
	}
	
};

int main(){
	// create the callbacks with the time they need to be executed w.r.t to the creation time
	callback c1("callback1", 10s);
	callback c2("callback2", 20s);
	callback c3("callback3", 30s);
	callback c4("callback4", 4s);
	callback c5("callback5", 50s);
	callback c6("callback6", 60s);

	CallbackMechanism *cm = new CallbackMechanism();
	//thread t1(&CallbackMechanism::execute, cm);// execution thread  - defines before every other thread

	// register callback threads
	// they are called randamly and not according to their time of execution
	thread t2(&CallbackMechanism::registerCallback, cm,std::ref(c5));
	thread t3(&CallbackMechanism::registerCallback, cm, std::ref(c3));
	thread t4(&CallbackMechanism::registerCallback, cm, std::ref(c1));
	thread t5(&CallbackMechanism::registerCallback, cm, std::ref(c2));
	thread t6(&CallbackMechanism::registerCallback, cm, std::ref(c4));
	thread t7(&CallbackMechanism::registerCallback, cm, std::ref(c6));
	thread t1(&CallbackMechanism::execute, cm);// execution thread - defined after every thread and join is also called after every thread's join
	// The thing here is that the executor will not stop running, so we need to manually exit it

	//t1.join(); -- defined before every thread
	t2.join();
	t3.join();
	t4.join();
	t5.join();
	t6.join();
	t7.join();
	t1.join();


	
	cout << "program concluded" << endl;

	return 0;
}

